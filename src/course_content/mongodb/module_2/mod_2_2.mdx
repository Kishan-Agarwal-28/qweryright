# Introduction to Accumulator Operators ($sum, $avg, $min, $max)

Accumulator operators are specialized expressions used primarily within the `$group` stage to perform calculations on a collection of documents. While the `$group` stage defines *how* documents are categorized (the "buckets"), accumulator operators define *what* information is calculated or extracted from the documents within each bucket. These operators are essential for deriving statistical insights, such as totals, averages, and extremes, from your data.

## Understanding Accumulator Mechanics

Accumulators work by processing the stream of documents entering a group one by one. For each document, the accumulator updates its internal stateâ€”adding a value to a running total, comparing a value to the current minimum, or adding an item to a list. Once all documents for a specific group have been processed, the accumulator returns the final result for that group.

It is important to note that most accumulators are only available in the `$group` stage, although some (like `$sum` and `$avg`) have counterparts available in `$project` or `$addFields` starting from MongoDB 3.2, but with slightly different syntax and behavior (operating on arrays within a single document rather than across multiple documents).

## Common Accumulator Operators

### The `$sum` Operator
The `$sum` operator calculates the total sum of numeric values. It ignores non-numeric values.

**Syntax:**
```javascript
{ $sum: /* expression */ }
{ $sum: /* number */ }
```

### The `$avg` Operator
The `$avg` operator calculates the mathematical average (mean) of all numeric values. Like `$sum`, it ignores non-numeric values.

**Syntax:**
```javascript
{ $avg: /* expression */ }
```

### The `$min` and `$max` Operators
The `$min` operator returns the lowest value encountered in the group, while `$max` returns the highest value. These operators work on numbers, dates, and strings (using lexicographical order).

**Syntax:**
```javascript
{ $min: /* expression */ }
{ $max: /* expression */ }
```

## Practical Examples and Demonstrations

### Scenario 1: Sales Performance Analysis
**Context:** We have a collection of sales transactions. We want to calculate the total revenue, average transaction value, lowest sale amount, and highest sale amount for each sales region.

**Sample Data:** `transactions` collection
```json
[
  { "_id": 1, "region": "North", "amount": 120.00, "date": ISODate("2023-01-10") },
  { "_id": 2, "region": "South", "amount": 450.50, "date": ISODate("2023-01-11") },
  { "_id": 3, "region": "North", "amount": 80.00, "date": ISODate("2023-01-12") },
  { "_id": 4, "region": "East", "amount": 200.00, "date": ISODate("2023-01-12") },
  { "_id": 5, "region": "South", "amount": 150.00, "date": ISODate("2023-01-13") },
  { "_id": 6, "region": "North", "amount": 300.00, "date": ISODate("2023-01-14") }
]
```

**Pipeline Code:**
```javascript
db.transactions.aggregate([
  {
    $group: {
      _id: "$region", // Group by region
      totalRevenue: { $sum: "$amount" }, // Calculate total sum of 'amount'
      averageTransaction: { $avg: "$amount" }, // Calculate average of 'amount'
      minSale: { $min: "$amount" }, // Find the smallest 'amount'
      maxSale: { $max: "$amount" }  // Find the largest 'amount'
    }
  }
]);
```

**Expected Output:**
```json
[
  {
    "_id": "East",
    "totalRevenue": 200.00,
    "averageTransaction": 200.00,
    "minSale": 200.00,
    "maxSale": 200.00
  },
  {
    "_id": "South",
    "totalRevenue": 600.50,
    "averageTransaction": 300.25,
    "minSale": 150.00,
    "maxSale": 450.50
  },
  {
    "_id": "North",
    "totalRevenue": 500.00,
    "averageTransaction": 166.66666666666666,
    "minSale": 80.00,
    "maxSale": 300.00
  }
]
```

**Explanation:**
- `_id: "$region"` creates a bucket for each unique region (North, South, East).
- `totalRevenue` accumulates the values of the `amount` field for all documents in that region.
- `averageTransaction` computes the mean of the `amount` field.
- `minSale` and `maxSale` scan the `amount` field to find the extremes.

### Scenario 2: Analyzing Student Test Scores
**Context:** A school database tracks student test scores across different subjects. We need to find the highest and lowest score for each subject to understand the difficulty spread.

**Sample Data:** `test_scores` collection
```json
[
  { "_id": 1, "subject": "Math", "score": 88, "studentId": "S01" },
  { "_id": 2, "subject": "Math", "score": 95, "studentId": "S02" },
  { "_id": 3, "subject": "Science", "score": 92, "studentId": "S01" },
  { "_id": 4, "subject": "Math", "score": 76, "studentId": "S03" },
  { "_id": 5, "subject": "Science", "score": 85, "studentId": "S02" }
]
```

**Pipeline Code:**
```javascript
db.test_scores.aggregate([
  {
    $group: {
      _id: "$subject",
      highestScore: { $max: "$score" },
      lowestScore: { $min: "$score" },
      numberOfExams: { $sum: 1 } // Counting documents using $sum: 1
    }
  }
]);
```

**Expected Output:**
```json
[
  {
    "_id": "Science",
    "highestScore": 92,
    "lowestScore": 85,
    "numberOfExams": 2
  },
  {
    "_id": "Math",
    "highestScore": 95,
    "lowestScore": 76,
    "numberOfExams": 3
  }
]
```

**Explanation:**
Here we use `$sum: 1`. This is a common pattern to count the number of documents in a group. For every document that passes through the group stage, the value `1` is added to the accumulator, effectively counting the rows.

## Handling Null or Missing Values
Accumulators handle missing data gracefully but with specific behaviors:
- `$sum` treats missing fields or nulls as 0.
- `$avg`, `$min`, and `$max` ignore missing fields or nulls completely. If all documents in a group have a missing or null value for the target field, the result will be `null`.

## Summary
Accumulator operators are the computational engine of the `$group` stage. By using `$sum`, `$avg`, `$min`, and `$max`, you can transform raw record-level data into meaningful aggregate statistics. These operators allow you to answer questions about totals, averages, and ranges within your datasets.

In the next lesson, we will explore **Using Multiple Accumulators and Compound Grouping Keys**, where we will combine these operators with more complex grouping logic to perform multi-dimensional analysis.