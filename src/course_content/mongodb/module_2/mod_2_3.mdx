# Using Multiple Accumulators and Compound Grouping Keys

The power of the `$group` stage is significantly amplified when you combine multiple accumulator operators with compound grouping keys. While simple grouping allows for basic categorization, compound grouping enables multi-dimensional analysis similar to pivot tables in spreadsheet software. By using multiple accumulators simultaneously, you can generate comprehensive reports that provide several different metrics (sums, averages, counts, extremes) for each unique group in a single pass.

## Understanding Compound Grouping Keys

A compound grouping key is created by setting the `_id` field to a document (an object) rather than a single field value. This tells MongoDB to group documents based on the unique combination of all fields within that `_id` document.

**Syntax:**
```javascript
{
  $group: {
    _id: {
      field1: "$path.to.field1",
      field2: "$path.to.field2"
    },
    // ... accumulators
  }
}
```

When using compound keys, the structure of the output `_id` will mirror the structure you defined. This preserves the relationship between the grouping dimensions and allows for easy sorting or further processing in subsequent stages.

## Using Multiple Accumulators

You are not limited to a single calculation per group. You can define as many accumulator fields as needed. This is particularly useful for generating "dashboard-style" data where you need to see the total revenue, average order size, and transaction count side-by-side for a given category.

## Practical Examples and Demonstrations

### Scenario 1: Regional Product Performance
**Context:** A retail chain wants to analyze product performance across different regions. Specifically, they need to know the total quantity sold and the total revenue generated for each product category within each region.

**Sample Data:** `sales_data` collection
```json
[
  { "_id": 1, "region": "North", "category": "Electronics", "quantity": 5, "total": 500 },
  { "_id": 2, "region": "North", "category": "Clothing", "quantity": 10, "total": 200 },
  { "_id": 3, "region": "South", "category": "Electronics", "quantity": 2, "total": 200 },
  { "_id": 4, "region": "North", "category": "Electronics", "quantity": 3, "total": 300 },
  { "_id": 5, "region": "South", "category": "Clothing", "quantity": 5, "total": 100 },
  { "_id": 6, "region": "South", "category": "Electronics", "quantity": 4, "total": 400 }
]
```

**Pipeline Code:**
```javascript
db.sales_data.aggregate([
  {
    $group: {
      // Compound Grouping Key
      _id: {
        region: "$region",
        category: "$category"
      },
      // Multiple Accumulators
      totalQuantity: { $sum: "$quantity" },
      totalRevenue: { $sum: "$total" },
      averageTransactionValue: { $avg: "$total" },
      transactionCount: { $sum: 1 }
    }
  },
  {
    $sort: { "_id.region": 1, "_id.category": 1 } // Optional: Sort for readability
  }
]);
```

**Expected Output:**
```json
[
  {
    "_id": { "region": "North", "category": "Clothing" },
    "totalQuantity": 10,
    "totalRevenue": 200,
    "averageTransactionValue": 200,
    "transactionCount": 1
  },
  {
    "_id": { "region": "North", "category": "Electronics" },
    "totalQuantity": 8,
    "totalRevenue": 800,
    "averageTransactionValue": 400,
    "transactionCount": 2
  },
  {
    "_id": { "region": "South", "category": "Clothing" },
    "totalQuantity": 5,
    "totalRevenue": 100,
    "averageTransactionValue": 100,
    "transactionCount": 1
  },
  {
    "_id": { "region": "South", "category": "Electronics" },
    "totalQuantity": 6,
    "totalRevenue": 600,
    "averageTransactionValue": 300,
    "transactionCount": 2
  }
]
```

**Explanation:**
- The `_id` field is an object containing both `region` and `category`. This creates a unique group for every combination (e.g., "North-Electronics" is distinct from "South-Electronics").
- We calculate four distinct metrics simultaneously: `totalQuantity`, `totalRevenue`, `averageTransactionValue`, and `transactionCount`.
- The output documents contain the complex `_id` object, which retains the context of the group.

### Scenario 2: Daily User Activity Logs
**Context:** An application logs user activities with timestamps. We want to summarize user activity by day, calculating the first login time, last login time, and total duration of sessions for each user on each specific date.

**Sample Data:** `user_sessions` collection
```json
[
  { "_id": 1, "user": "Alice", "login": ISODate("2023-01-01T09:00:00Z"), "durationMinutes": 30 },
  { "_id": 2, "user": "Alice", "login": ISODate("2023-01-01T14:00:00Z"), "durationMinutes": 45 },
  { "_id": 3, "user": "Bob", "login": ISODate("2023-01-01T10:00:00Z"), "durationMinutes": 60 },
  { "_id": 4, "user": "Alice", "login": ISODate("2023-01-02T09:30:00Z"), "durationMinutes": 20 }
]
```

**Pipeline Code:**
```javascript
db.user_sessions.aggregate([
  {
    $group: {
      _id: {
        user: "$user",
        date: { $dateToString: { format: "%Y-%m-%d", date: "$login" } } // Extracting date part
      },
      firstLogin: { $min: "$login" },
      lastLogin: { $max: "$login" },
      totalDuration: { $sum: "$durationMinutes" },
      sessionCount: { $sum: 1 }
    }
  }
]);
```

**Expected Output:**
```json
[
  {
    "_id": { "user": "Bob", "date": "2023-01-01" },
    "firstLogin": ISODate("2023-01-01T10:00:00Z"),
    "lastLogin": ISODate("2023-01-01T10:00:00Z"),
    "totalDuration": 60,
    "sessionCount": 1
  },
  {
    "_id": { "user": "Alice", "date": "2023-01-02" },
    "firstLogin": ISODate("2023-01-02T09:30:00Z"),
    "lastLogin": ISODate("2023-01-02T09:30:00Z"),
    "totalDuration": 20,
    "sessionCount": 1
  },
  {
    "_id": { "user": "Alice", "date": "2023-01-01" },
    "firstLogin": ISODate("2023-01-01T09:00:00Z"),
    "lastLogin": ISODate("2023-01-01T14:00:00Z"),
    "totalDuration": 75,
    "sessionCount": 2
  }
]
```

**Explanation:**
- We use `$dateToString` (a date operator) inside the `_id` definition to group by the calendar date, ignoring the specific time component.
- `firstLogin` uses `$min` to find the earliest timestamp.
- `lastLogin` uses `$max` to find the latest timestamp.
- This effectively summarizes a user's "day" into a single document.

## Summary
Combining compound grouping keys with multiple accumulators transforms the `$group` stage from a simple calculator into a powerful reporting engine. You can slice your data by multiple dimensions (like Region + Category or User + Date) and simultaneously derive a wide array of statistical insights.

In the next lesson, we will look at **The `$count` Stage**, a specialized stage designed for the specific and common task of counting documents efficiently.