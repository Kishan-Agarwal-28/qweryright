# The `$project` Stage: Reshaping Document Output

The $project stage in MongoDB aggregation pipelines allows for the reshaping of documents by including, excluding, or renaming fields, as well as computing new fields based on existing data. This stage is crucial for controlling the output structure of your aggregation results, enabling you to present data in a format optimized for subsequent processing or final consumption. It operates on each document as it passes through the pipeline, transforming its structure without altering the original documents in the collection.

## Understanding $project Mechanics

The $project stage takes a document that specifies the inclusion, exclusion, or computation of fields. Each field in the projection document can be set to one of the following:

1 or true: To include a field.
0 or false: To exclude a field. Note that you cannot mix inclusion and exclusion of fields explicitly, except for the _id field.
An aggregation expression: To compute a new field or reshape an existing one. This is where the true power of $project lies, as it allows for complex transformations.
By default, the _id field is included in the output documents unless explicitly excluded. If you explicitly include any fields (other than _id), the _id field is excluded by default, unless you explicitly include it.

## Including and Excluding Fields

You can use $project to select a subset of fields from your documents. This is useful for reducing the amount of data transferred and processed in subsequent stages, making your pipelines more efficient.

Consider a products collection with documents like this:

```json
[
  {
    "_id": ObjectId("651d2f7e09e1c3e3a4b5c6d7"),
    "name": "Laptop Pro X",
    "category": "Electronics",
    "price": 1200,
    "stock": 50,
    "manufacturer": {
      "name": "TechCorp",
      "country": "USA"
    },
    "tags": ["portable", "high-performance"]
  },
  {
    "_id": ObjectId("651d2f7e09e1c3e3a4b5c6d8"),
    "name": "Wireless Mouse Z",
    "category": "Accessories",
    "price": 25,
    "stock": 200,
    "manufacturer": {
      "name": "GadgetCo",
      "country": "China"
    },
    "tags": ["ergonomic", "wireless"]
  },
  {
    "_id": ObjectId("651d2f7e09e1c3e3a4b5c6d9"),
    "name": "Mechanical Keyboard K",
    "category": "Accessories",
    "price": 80,
    "stock": 100,
    "manufacturer": {
      "name": "TechCorp",
      "country": "USA"
    },
    "tags": ["gaming", "backlit"]
  }
]
```
To only retrieve the name and price of products:

```javascript
db.products.aggregate([
  {
    $project: {
      name: 1, // Include the 'name' field
      price: 1, // Include the 'price' field
      _id: 0 // Exclude the default '_id' field
    }
  }
]);
```
Output:

```json
[
  { "name": "Laptop Pro X", "price": 1200 },
  { "name": "Wireless Mouse Z", "price": 25 },
  { "name": "Mechanical Keyboard K", "price": 80 }
]
To include all fields except stock:

```javascript
db.products.aggregate([
  {
    $project: {
      stock: 0 // Exclude the 'stock' field
      // _id is included by default as we didn't specify other inclusions
    }
  }
]);
```
Output:

```json
[
  {
    "_id": ObjectId("651d2f7e09e1c3e3a4b5c6d7"),
    "name": "Laptop Pro X",
    "category": "Electronics",
    "price": 1200,
    "manufacturer": {
      "name": "TechCorp",
      "country": "USA"
    },
    "tags": ["portable", "high-performance"]
  },
  {
    "_id": ObjectId("651d2f7e09e1c3e3a4b5c6d8"),
    "name": "Wireless Mouse Z",
    "category": "Accessories",
    "price": 25,
    "manufacturer": {
      "name": "GadgetCo",
      "country": "China"
    },
    "tags": ["ergonomic", "wireless"]
  },
  {
    "_id": ObjectId("651d2f7e09e1c3e3a4b5c6d9"),
    "name": "Mechanical Keyboard K",
    "category": "Accessories",
    "price": 80,
    "manufacturer": {
      "name": "TechCorp",
      "country": "USA"
    },
    "tags": ["gaming", "backlit"]
  }
]

```



## Renaming Fields

You can rename fields by specifying the new field name as the key and the old field name (prefixed with $) as the value.

To rename name to productName and price to unitPrice:

```javascript
db.products.aggregate([
  {
    $project: {
      productName: "$name", // Rename 'name' to 'productName'
      unitPrice: "$price", // Rename 'price' to 'unitPrice'
      _id: 0 // Exclude the default '_id' field
    }
  }
]);
```
Output:

```json
[
  { "productName": "Laptop Pro X", "unitPrice": 1200 },
  { "productName": "Wireless Mouse Z", "unitPrice": 25 },
  { "productName": "Mechanical Keyboard K", "unitPrice": 80 }
]
```

## Reshaping and Computing New Fields

This is where `$project` becomes extremely powerful. You can use aggregation expressions to perform calculations, string manipulations, array operations, and more, creating entirely new fields or transforming existing ones.

### Simple Calculations

Let's calculate the totalValue for each product, assuming a hypothetical taxRate of 0.05.

```javascript
db.products.aggregate([
  {
    $project: {
      name: 1,
      price: 1,
      // Calculate totalValue as price * (1 + taxRate)
      totalValue: { $multiply: ["$price", 1.05] },
      _id: 0
    }
  }
]);
```
Output:

```json
[
  { "name": "Laptop Pro X", "price": 1200, "totalValue": 1260 },
  { "name": "Wireless Mouse Z", "price": 25, "totalValue": 26.25 },
  { "name": "Mechanical Keyboard K", "price": 80, "totalValue": 84 }
]

```


### Accessing Nested Fields

To pull a nested field to the top level or rename it:

```javascript
db.products.aggregate([
  {
    $project: {
      productName: "$name",
      manufacturerName: "$manufacturer.name", // Access nested field
      _id: 0
    }
  }
]);
```
Output:

```json
[
  { "productName": "Laptop Pro X", "manufacturerName": "TechCorp" },
  { "productName": "Wireless Mouse Z", "manufacturerName": "GadgetCo" },
  { "productName": "Mechanical Keyboard K", "manufacturerName": "TechCorp" }
]

```


### Array Operations

You can use array operators to transform array fields. For instance, to get the first tag of each product:

```javascript
db.products.aggregate([
  {
    $project: {
      name: 1,
      firstTag: { $arrayElemAt: ["$tags", 0] }, // Get the first element of the 'tags' array
      _id: 0
    }
  }
]);
```
Output:

```json
[
  { "name": "Laptop Pro X", "firstTag": "portable" },
  { "name": "Wireless Mouse Z", "firstTag": "ergonomic" },
  { "name": "Mechanical Keyboard K", "firstTag": "gaming" }
]

```



### Concatenating Strings

To create a fullProductDescription combining the name and category:

```javascript
db.products.aggregate([
  {
    $project: {
      productName: "$name",
      category: "$category",
      fullProductDescription: {
        $concat: ["$name", " (", "$category", ")"]
      }, // Concatenate strings
      _id: 0
    }
  }
]);
```
Output:

```json
[
  {
    "productName": "Laptop Pro X",
    "category": "Electronics",
    "fullProductDescription": "Laptop Pro X (Electronics)"
  },
  {
    "productName": "Wireless Mouse Z",
    "category": "Accessories",
    "fullProductDescription": "Wireless Mouse Z (Accessories)"
  },
  {
    "productName": "Mechanical Keyboard K",
    "category": "Accessories",
    "fullProductDescription": "Mechanical Keyboard K (Accessories)"
  }
]

```


## Practical Examples and Demonstrations

Let's use a hypothetical orders collection to demonstrate more complex reshaping with $project.

orders collection sample documents:

```json
[
  {
    "_id": ObjectId("651d2f7e09e1c3e3a4b5c6e0"),
    "orderId": "ORD001",
    "customerId": "CUST001",
    "orderDate": ISODate("2023-09-15T10:00:00Z"),
    "items": [
      { "productId": "PROD001", "quantity": 2, "unitPrice": 50 },
      { "productId": "PROD002", "quantity": 1, "unitPrice": 120 }
    ],
    "shippingAddress": {
      "street": "123 Main St",
      "city": "Anytown",
      "zip": "12345"
    },
    "status": "completed"
  },
  {
    "_id": ObjectId("651d2f7e09e1c3e3a4b5c6e1"),
    "orderId": "ORD002",
    "customerId": "CUST002",
    "orderDate": ISODate("2023-09-16T11:30:00Z"),
    "items": [
      { "productId": "PROD003", "quantity": 1, "unitPrice": 200 }
    ],
    "shippingAddress": {
      "street": "456 Oak Ave",
      "city": "Otherville",
      "zip": "67890"
    },
    "status": "pending"
  }
]

```

### Example 1: Extracting Specific Order Information

We want to see the orderId, customerId, and a simplified shippingCity.

```javascript
db.orders.aggregate([
  {
    $project: {
      _id: 0, // Exclude the default _id
      orderIdentifier: "$orderId", // Rename orderId
      customerRef: "$customerId", // Rename customerId
      shippingCity: "$shippingAddress.city" // Extract nested city
    }
  }
]);
```
Output:

```json
[
  {
    "orderIdentifier": "ORD001",
    "customerRef": "CUST001",
    "shippingCity": "Anytown"
  },
  {
    "orderIdentifier": "ORD002",
    "customerRef": "CUST002",
    "shippingCity": "Otherville"
  }
]
```

### Example 2: Calculating Total Price Per Item in an Order

Here, we want to add a `totalPrice` field within each item object, calculated as `quantity * unitPrice`. This requires using a `$map` expression to iterate over the items array.

```javascript
db.orders.aggregate([
  {
    $project: {
      _id: 0,
      orderId: 1,
      customerId: 1,
      orderDate: 1,
      items: {
        $map: {
          input: "$items", // The array to iterate over
          as: "item", // Variable name for each element
          in: {
            productId: "$$item.productId",
            quantity: "$$item.quantity",
            unitPrice: "$$item.unitPrice",
            // Calculate total price for each item
            totalPrice: { $multiply: ["$$item.quantity", "$$item.unitPrice"] }
          }
        }
      }
    }
  }
]);
```
Output:

```json
[
  {
    "orderId": "ORD001",
    "customerId": "CUST001",
    "orderDate": ISODate("2023-09-15T10:00:00Z"),
    "items": [
      { "productId": "PROD001", "quantity": 2, "unitPrice": 50, "totalPrice": 100 },
      { "productId": "PROD002", "quantity": 1, "unitPrice": 120, "totalPrice": 120 }
    ]
  },
  {
    "orderId": "ORD002",
    "customerId": "CUST002",
    "orderDate": ISODate("2023-09-16T11:30:00Z"),
    "items": [
      { "productId": "PROD003", "quantity": 1, "unitPrice": 200, "totalPrice": 200 }
    ]
  }
]

```



### Example 3: Combining $match and $project

As discussed in the previous lesson, using $match early in the pipeline is crucial for performance. We can combine it with $project to filter documents first, then reshape them.

Let's find all completed orders and project only their orderId and the number of items in the order.

```javascript
db.orders.aggregate([
  {
    $match: {
      status: "completed" // Filter for completed orders
    }
  },
  {
    $project: {
      _id: 0,
      orderId: 1,
      numberOfItems: { $size: "$items" } // Calculate the size of the 'items' array
    }
  }
]);
```
Output:

```json
[
  { "orderId": "ORD001", "numberOfItems": 2 }
]
This demonstrates how $project can be used to prepare data for further aggregation stages or for final display. Its flexibility with aggregation expressions allows for significant data transformation within the pipeline.

```


## Exercises

**Product Inventory Projection:** Using the products collection, create an aggregation pipeline that:

- Filters for products in the "Electronics" category.
- Projects the name, price, stock, and creates a new field inventoryValue calculated as price * stock.
- Excludes the _id field.
- Renames name to productName.

**Order Summary with Conditional Status:** Using the orders collection, create an aggregation pipeline that:

- Projects the orderId, customerId.
- Creates a new field deliveryStatus which is "Delivered" if status is "completed", and "In Progress" otherwise. Use a conditional operator ($cond).
- Excludes the _id, items, and shippingAddress fields.

**Manufacturer Location:** Using the products collection, create an aggregation pipeline that:

- Projects the name (as productTitle), the manufacturer.name (as vendorName), and the manufacturer.country (as vendorCountry).
- Creates a new field fullVendorLocation by concatenating vendorName and vendorCountry (e.g., "TechCorp (USA)").
- Excludes all other fields.

## Real-World Application

### Scenario: E-commerce Product Listing API
An e-commerce platform needs to display a simplified list of products on its category pages. The full product documents contain a lot of internal data not relevant for a quick listing (e.g., internal SKUs, supplier details, extensive descriptions). The API requires only the product's name, current price, and a flag indicating if it's currently in stock.

Problem: The products collection has documents with many fields, including nested objects and arrays. Goal: Create an API endpoint that provides a lightweight response for product listings.

Solution using $project:

```javascript
// Sample products data (similar to above)
/*
[
  {
    "_id": ObjectId("..."),
    "name": "Super Widget",
    "category": "Gadgets",
    "price": 99.99,
    "stock": 15,
    "description": "A fantastic widget...",
    "images": ["url1", "url2"],
    "internalSKU": "SW12345",
    "supplierInfo": { "name": "Global Supplies", "contact": "..." }
  },
  // ... more products
]
*/
db.products.aggregate([
  {
    $project: {
      _id: 0, // Exclude the internal MongoDB _id
      productName: "$name", // Rename 'name' for clarity in the API
      currentPrice: "$price", // Rename 'price'
      inStock: { $gt: ["$stock", 0] } // Compute a boolean field 'inStock' based on 'stock' quantity
    }
  }
]);
```
Output for the API:

```json
[
  { "productName": "Super Widget", "currentPrice": 99.99, "inStock": true },
  { "productName": "Mega Device", "currentPrice": 149.50, "inStock": false } // If stock was 0
]
```

This `$project` stage effectively transforms the comprehensive product documents into a streamlined format, containing only the necessary fields for the category listing page. This reduces payload size, improves API response times, and simplifies data consumption for the front-end application.

## Conclusion and Next Steps

The `$project` stage is a fundamental building block in MongoDB aggregation pipelines, enabling precise control over the structure and content of your documents. You learned how to include and exclude fields, rename them, and most importantly, compute new fields using a wide array of aggregation expressions. Its ability to reshape data makes it indispensable for preparing documents for subsequent pipeline stages or for final consumption by an application.

In the next lesson, you will apply the knowledge gained from `$match` and `$project` in a hands-on lab. This will solidify your understanding of these core stages and prepare you for more advanced data manipulation techniques in subsequent modules.