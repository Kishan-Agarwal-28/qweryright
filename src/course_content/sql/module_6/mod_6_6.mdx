# Introduction to Transactions and Concurrency Control

In a busy **Online Bookstore**, hundreds of customers are buying books at the same second. What happens if two people try to buy the *last copy* of "1984" at the exact same moment? Or what happens if the server crashes right after we charge a credit card but *before* we create the order record?

To handle these critical scenarios, databases use **Transactions**.

## Understanding Transactions (ACID)

A transaction is a sequence of SQL operations that are treated as a single unit of work.
*   **Atomicity:** All or nothing. If one part fails, everything is undone.
*   **Consistency:** The database moves from one valid state to another.
*   **Isolation:** Transactions don't interfere with each other.
*   **Durability:** Once saved, it stays saved.

## Basic Syntax

*   **`BEGIN`**: Starts the transaction.
*   **`COMMIT`**: Saves the changes permanently.
*   **`ROLLBACK`**: Undoes all changes since the `BEGIN`.

## Practical Examples and Demonstrations

Let's apply this to our **Online Bookstore**.

### Scenario 1: The Purchase (All or Nothing)
A customer buys a book. We need to:
1.  Create an Order record.
2.  Decrease the Book inventory by 1.

If step 2 fails (e.g., out of stock), we MUST undo step 1. We can't have an order for a book we don't have.

**Query:**
```sql
BEGIN;

-- Step 1: Create Order
INSERT INTO orders (customer_id, total_amount) VALUES (101, 20.00);

-- Step 2: Update Inventory
UPDATE books SET stock_quantity = stock_quantity - 1 WHERE book_id = 500;

-- If everything is okay:
COMMIT;
```

**The Rollback Scenario:**
If the database throws an error at Step 2 (e.g., "Constraint Violation: stock cannot be negative"), the system (or your application code) issues a `ROLLBACK`. The `INSERT` in Step 1 disappears as if it never happened.

### Scenario 2: Concurrency (The Race Condition)
User A and User B both see 1 copy of a book.
1.  User A: `SELECT stock FROM books` -> sees 1.
2.  User B: `SELECT stock FROM books` -> sees 1.
3.  User A buys it. Stock -> 0.
4.  User B buys it. Stock -> -1. (Error!)

Transactions isolate these users. Depending on the **Isolation Level**, User B might be forced to wait until User A finishes, or User B's transaction might fail immediately, telling them "Sorry, item no longer available."

## Exercises and Practice Activities

To solidify your understanding, complete the following exercises.

### Exercise 1: The Bank Transfer
Write the pseudo-code (SQL) for transferring $100 from Account A to Account B using a transaction. What happens if the system crashes after deducting from A but before adding to B?

### Exercise 2: The Rollback
Open a transaction, delete a row from a test table, and then run `ROLLBACK`. Check the table. Is the row still there?

### Exercise 3: ACID
Which letter of ACID ensures that a committed transaction survives a power outage?

## Concluding Thoughts

In this lesson, we learned how to ensure data integrity using Transactions. This is the bedrock of trust in any database system.

This concludes Module 6. We have covered the full lifecycle of a database: Design (Normalization), Creation (DDL), Optimization (Indexes), and Protection (Transactions).

In **Module 7**, the final module, we will explore **Advanced Analytics**. We will look at complex Window Functions (`LAG`, `LEAD`), JSON data, and how to build data for dashboards.

=START_QUESTIONS=What command starts a transaction?@@What command saves the changes permanently?@@What command undoes the changes?@@What does the 'A' in ACID stand for? =END_QUESTIONS=