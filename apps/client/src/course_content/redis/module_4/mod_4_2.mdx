# Redis Transactions (MULTI/EXEC)

In most database systems, a **Transaction** is a way to ensure that a group of operations either all succeed together or all fail together. Redis also supports transactions, though they work a bit differently than the "ACID" transactions you might know from SQL.

---

## 1. How Redis Transactions Work

A Redis transaction is a "block" of commands that are queued up and then executed sequentially without any other client's command being allowed to "interrupt" them.

### The Four Commands

1. **MULTI:** Tells Redis you are starting a transaction.
2. **[Your Commands]:** You send your `SET`, `INCR`, `SADD` etc. Redis responds with `QUEUED` instead of executing them immediately.
3. **EXEC:** Tells Redis to execute all the queued commands at once.
4. **DISCARD:** Tells Redis to "forget" the queued commands and end the transaction.

### Example

```bash
MULTI
SET user:1:name "Alice"
INCR user:1:login_count
SADD active_users "user:1"
EXEC
```

- Between `MULTI` and `EXEC`, no other client can change `user:1:name`. All three commands happen as one continuous "burst."

---

## 2. Transactions and Errors

This is where Redis is different from SQL.

- **Syntax Errors:** If you type a command wrong (e.g., `SETT` instead of `SET`), Redis will detect this during the queueing phase and the whole transaction will fail when you run `EXEC`.
- **Runtime Errors:** If you try to run a command that is logically wrong (e.g., running `SADD` on a key that is actually a String), **Redis will still execute the other commands in the transaction.** It does _not_ roll back.

### Why no Rollback?

Redis is designed for extreme speed. Implementing "Rollbacks" would require complex undo logs and would significantly slow down the database. The Redis philosophy is that runtime errors are usually bugs in your application code that should be caught during testing.

---

## 3. Optimistic Locking with WATCH

What if you want to update a value, but _only if_ it hasn't changed since you last looked at it? This is called **Optimistic Locking**.

### The Problem

1. You `GET balance` (It's 100).
2. You calculate 100 - 10 = 90.
3. You start a `MULTI` to `SET balance 90`.
4. **BUT wait!** Between step 1 and step 3, another process deducted $5. The balance is actually 95. If you set it to 90, you just "stole" $5 from the database.

### The Solution: WATCH

```bash
# Tell Redis to watch the 'balance' key
WATCH balance
current_bal = GET balance  # assume 100

MULTI
SET balance 90
EXEC
```

If any other client changes the `balance` key between the `WATCH` and the `EXEC` command, the `EXEC` will return `(nil)`, meaning the transaction failed. You then simple "try again" with the new value.

---

## Real-World Example: An In-Game Item Trade

Imagine two players, Alice and Bob, trading items in an RPG.

1. **Transaction Start:** `MULTI`
2. **Step 1:** `SREM alice:inventory "Magic_Sword"`
3. **Step 2:** `SADD bob:inventory "Magic_Sword"`
4. **Step 3:** `HINCRBY bob:gold -50`
5. **Step 4:** `HINCRBY alice:gold 50`
6. **Execution:** `EXEC`

By using a transaction, we ensure that the Magic Sword doesn't accidentally vanish from the world or get "cloned" if the server is busy.

## Exercises

1. **Transaction Flow:** Open your `redis-cli` and run a `MULTI` block that sets two keys and increments a third. Run `EXEC`. Use `GET` to verify all three changed.
2. **Error Handling:** Start a `MULTI` block. Run `SET a 1` and then run a nonsense command like `HSET a field 1` (this will fail because `a` is a string). Run `EXEC`. Does `a` still equal 1?
3. **Watch Practice:** Open two terminals. In Terminal 1, `WATCH mykey`. In Terminal 2, `SET mykey 10`. In Terminal 1, try to run a `MULTI` / `SET mykey 20` / `EXEC` block. What happens?

## Summary and Next Steps

Redis Transactions provide a way to group commands for atomic execution. While they don't have traditional SQL rollbacks, they are incredibly fast and, when combined with `WATCH`, allow for safe concurrent data updates.

In the final lesson of this module, we will explore the most advanced way to run logic in Redis: **Lua Scripting**.
