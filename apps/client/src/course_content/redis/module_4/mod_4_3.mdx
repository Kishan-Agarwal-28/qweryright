# Lua Scripting with EVAL

In the previous lesson, we saw how Transactions (`MULTI/EXEC`) allow you to group commands. However, Transactions have a limitation: you cannot use the _result_ of one command as an _input_ for the next one within the same block.

If you need complex logic (if/else statements, loops) to happen inside the database at lightning speed, you use **Lua Scripting**.

---

## 1. What is Lua Scripting?

**Lua** is a lightweight, high-performance programming language. Redis comes with a built-in Lua engine.

### Why run scripts inside Redis?

- **Atomicity:** A Lua script is treated like a single command. No other command can run while the script is executing.
- **Efficiency:** Instead of sending 10 separate commands over the network (causing "network lag"), you send one script that does all 10 operations locally on the server.
- **Logic power:** You can use `if` statements, `for` loops, and math operations that aren't available in standard Redis commands.

---

## 2. Basic Syntax: EVAL

To run a script, you use the `EVAL` command.

```bash
EVAL "return 'Hello Redis!'" 0
```

- The first part is the **Script**.
- The `0` is the **Number of Keys** used in the script.

### Using Keys and Arguments

Redis scripts should never hard-code key names. instead, you pass them as parameters.

```bash
# A script to increment a key only if it exists
EVAL "if redis.call('exists', KEYS[1]) == 1 then return redis.call('incr', KEYS[1]) else return 0 end" 1 my_counter
```

- `KEYS[1]` refers to `my_counter`.
- `redis.call` is how the Lua script runs a standard Redis command.

---

## 3. Script Caching (EVALSHA)

Sending a long script over the network every time you want to run it is wasteful. Instead, Redis allows you to "load" the script once.

1. **Load it:** `SCRIPT LOAD "return redis.call('get', KEYS[1])"`
   - Redis returns a **SHA1 hash** (e.g., `bfbfba34...`).
2. **Run it:** `EVALSHA bfbfba34... 1 mykey`
   - This is incredibly fast because you are only sending a short hash instead of the whole code.

---

## Real-World Example: A Complex Rate Limiter

Standard rate limiting (X requests per minute) can be done with `INCR`. But what if you want a **Sliding Window**? (e.g., No more than 100 requests in any 60-second period).

1. You use a **Sorted Set** (`ZSET`) where the `score` is the timestamp of the request.
2. The Lua script:
   - Removes all timestamps older than 60 seconds (`ZREMRANGEBYSCORE`).
   - Counts how many items are left (`ZCARD`).
   - If count < 100, adds the current timestamp (`ZADD`) and returns "Allowed".
   - Else, returns "Blocked".

Because this is a Lua script, the entire "Check -> Clean -> Count -> Add" sequence happens **atomically**. No other request can sneak in between the "Check" and the "Add".

---

## Hypothetical Scenario: The "Inventory Check and Buy"

In an MMO game, a player wants to buy a "Dragon Egg" for 500 gold.

**The Script:**

```lua
local price = 500
local gold = tonumber(redis.call('hget', KEYS[1], 'gold'))
local stock = tonumber(redis.call('get', KEYS[2]))

if gold >= price and stock > 0 then
    redis.call('hincrby', KEYS[1], 'gold', -price)
    redis.call('decr', KEYS[2])
    return "SUCCESS"
else
    return "FAILURE"
end
```

- This ensures that we never sell an item if the player is too poor, and we never let the stock go below zero, all without needing complex "WATCH" logic or multiple network round-trips.

## Exercises

1. **Simple Script:** Write an `EVAL` command that adds two numbers passed as arguments (`ARGV[1]` and `ARGV[2]`) and returns the sum.
2. **Conditional Logic:** Write a script that checks if a key exists. If it does, return `1`. If not, set the key to "initialized" and return `0`.
3. **Efficiency Check:** Why is `EVALSHA` better than `EVAL` for a production application that runs the same script 10,000 times a second?

## Summary and Next Steps

Lua Scripting is the ultimate "power user" feature in Redis. It allows you to extend the database with your own custom, atomic logic. By mastering Lua, you can solve complex concurrency problems that would be impossible with standard commands alone.

Now that we've covered the advanced logic and infrastructure, it's time to move to the most practical part of the course: **Caching Patterns**.
